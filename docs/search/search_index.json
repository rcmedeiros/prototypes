{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"@rcmedeiros/prototypes General purpose JavaScript prototypes library. Use it if you\u2026 Must comply with OWASP or SANS and would avoid using any method which accept regular expressions as argument; Customize dates representation but not that much to justify a heavy specialized package; Do lots of Math functions; \u2018re just lazy :) This package comes with no dependencies whatsoever. You\u2019ll only add the from the source code. Note The module comes with its Declaration File , meaning it can be imported seamlessly to a TypeScript project. Install npm install --save @rcmedeiros/prototypes Usage Just import it in the first module your package loads, maybe index.js/ts. No need to keep reference. TypeScript typings are included. import '@rcmedeiros/prototypes' ;","title":"Home"},{"location":"#rcmedeirosprototypes","text":"General purpose JavaScript prototypes library. Use it if you\u2026 Must comply with OWASP or SANS and would avoid using any method which accept regular expressions as argument; Customize dates representation but not that much to justify a heavy specialized package; Do lots of Math functions; \u2018re just lazy :) This package comes with no dependencies whatsoever. You\u2019ll only add the from the source code. Note The module comes with its Declaration File , meaning it can be imported seamlessly to a TypeScript project.","title":"@rcmedeiros/prototypes"},{"location":"#install","text":"npm install --save @rcmedeiros/prototypes","title":"Install"},{"location":"#usage","text":"Just import it in the first module your package loads, maybe index.js/ts. No need to keep reference. TypeScript typings are included. import '@rcmedeiros/prototypes' ;","title":"Usage"},{"location":"array/","text":"Array first Array<T>.prototype.first(): T Returns the first item of an array const arr = [ 1 , 2 , 3 , 4 , 5 ]; const first = arr . first (); // => 1 last Array<T>.prototype.last(): T Returns the last item of an array const arr = [ 1 , 2 , 3 , 4 , 5 ]; const last = arr . last (); // => 5 secondLast Array<T>.prototype.secondLast(): T Returns the second last item of an array const arr = [ 1 , 2 , 3 , 4 , 5 ]; const first = arr . secondLast (); // => 4","title":"array"},{"location":"array/#array","text":"","title":"Array"},{"location":"array/#first","text":"Array<T>.prototype.first(): T Returns the first item of an array const arr = [ 1 , 2 , 3 , 4 , 5 ]; const first = arr . first (); // => 1","title":"first"},{"location":"array/#last","text":"Array<T>.prototype.last(): T Returns the last item of an array const arr = [ 1 , 2 , 3 , 4 , 5 ]; const last = arr . last (); // => 5","title":"last"},{"location":"array/#secondlast","text":"Array<T>.prototype.secondLast(): T Returns the second last item of an array const arr = [ 1 , 2 , 3 , 4 , 5 ]; const first = arr . secondLast (); // => 4","title":"secondLast"},{"location":"date/","text":"Date Important Always work in UTC , regardless if you\u2019re in the back end, front end, or even in the wrong end of a deadline. The only exception is if you need to display the data, but only if the data displayed is not coming back to the system, tainted with a local time offset. All of these functions works internally in UTC. But if for whatever reason you stubbornly decides that local time is a thing, keep in mind that: * In an ISO 8601 string, time zone designators are in the format \u00b1hh:mm , \u00b1hhmm , \u00b1hh , or an upper cased Z at the end. This Z, or Zulu Time , is the military designation for UTC+0 and shortcuts to +0000 . * Buf if no time designators are provided, the ISO 8601 states that local time is to be assumed. Blatantly contradicting the standard, these functions will assume UTC instead. Constants Date . MIN = - 8640000000000000 ; // Somewhere in 271.821 BC Date . MAX = 8640000000000000 ; // Somewhere in 275.760 AD Returns minimum and maximum datetime values for sheer programmatic convenience. fromFormattedNumber Date.prototype.fromFormattedNumber(dateNumber: number, pattern: string): Date The same as the above function, accepting only full elements with no separators as pattern . const d = new Date ( 2019 , 5 , 11 ); d . fromFormattedNumber ( 20190906 , 'yyyyMMdd' ); // => Sun Jun 09 2019 00:00:00 GMT+0000 fromFormattedString Date.prototype.fromFormattedString(dateString: string, pattern: string): Date Returns a new Date object based on the informed pattern . const d = new Date (); d . fromFormattedString ( '6/9/19 11:50 pm GMT +05:30' , 'M/d/yy h:m a z' ); // => Sat Jun 09 2018 18:20:00 GMT+0000 (Greenwich Mean Time) // => Sat Jun 09 2018 19:20:00 GMT+0100 (British Summer Time) // => Sat Jun 09 2018 15:20:00 GMT-0300 (Atlantic Daylight Time) // => Sun Jun 10 2018 02:20:00 GMT+0800 (China Standard Time) A pattern take only its reserved characters into consideration. Any other character is considered a separator. Two consecutive separators aren\u2019t allowed. If the pattern has no separator, the date string doesn\u2019t either. In this case, only full elements (with leading zeros) are allowed. If a separator in the pattern doesn\u2019t match a separator in the date string, with the same sequence, or if the content between two separators isn\u2019t numeric, an error will be raised. If a pattern element isn\u2019t recognized, an error will be raised. toFormattedNumber toFormattedNumber(pattern?: string, timeZone?: string): string toFormattedNumber(pattern?: string, localTime?: boolean): string The same as the above function, accepting no separators as pattern . const d = new Date ( 2019 , 5 , 11 ); d . fromFormattedNumber ( 20190906 , 'yyyyMMdd' ); // => Sun Jun 09 2019 00:00:00 GMT+0000 toFormattedString Date.prototype.toFormattedString(pattern?: string, timeZone?: string): string Date.prototype.toFormattedString(pattern?: string, localTime?: boolean): string Returns the date according to the specified pattern . If no pattern is specified, ISO 8601 ( 'yyyy-MM-ddTHH:mm:ssZ' ) is assumed; If no time zone is specified, UTC is assumed; Instead of a time zone, you can send true to the second parameter, thus assuming the environment local time. const d = new Date ( Date . UTC ( 2018 , 5 , 9 , 16 , 0 , 30 , 95 )); d . toFormattedString ()); // 1980-06-09T16:00:30+0000 d . toFormattedString ( 'yyyy/MM/dd HH:mm:ssZ' , 'GMT +01:00' ); // 1980/06/09 17:00:30+0100 d . toFormattedString ( 'yyyy/MM/dd HH:mm:ssZ' , '-0100' ); // 1980/06/09 15:00:30-0100 d . toFormattedString ( 'yyyy/MM/dd HH:mm:ss (z)' , true ); // 1980/06/09 13:00:30 (GMT -03:00) toLocalISOString Date.prototype.toLocalISOString(): string Returns local time in ISO 8601 format const d = new Date (); d . toLocalISOString (); // Just like toISOString(), but in the local format","title":"date"},{"location":"date/#date","text":"Important Always work in UTC , regardless if you\u2019re in the back end, front end, or even in the wrong end of a deadline. The only exception is if you need to display the data, but only if the data displayed is not coming back to the system, tainted with a local time offset. All of these functions works internally in UTC. But if for whatever reason you stubbornly decides that local time is a thing, keep in mind that: * In an ISO 8601 string, time zone designators are in the format \u00b1hh:mm , \u00b1hhmm , \u00b1hh , or an upper cased Z at the end. This Z, or Zulu Time , is the military designation for UTC+0 and shortcuts to +0000 . * Buf if no time designators are provided, the ISO 8601 states that local time is to be assumed. Blatantly contradicting the standard, these functions will assume UTC instead.","title":"Date"},{"location":"date/#constants","text":"Date . MIN = - 8640000000000000 ; // Somewhere in 271.821 BC Date . MAX = 8640000000000000 ; // Somewhere in 275.760 AD Returns minimum and maximum datetime values for sheer programmatic convenience.","title":"Constants"},{"location":"date/#fromformattednumber","text":"Date.prototype.fromFormattedNumber(dateNumber: number, pattern: string): Date The same as the above function, accepting only full elements with no separators as pattern . const d = new Date ( 2019 , 5 , 11 ); d . fromFormattedNumber ( 20190906 , 'yyyyMMdd' ); // => Sun Jun 09 2019 00:00:00 GMT+0000","title":"fromFormattedNumber"},{"location":"date/#fromformattedstring","text":"Date.prototype.fromFormattedString(dateString: string, pattern: string): Date Returns a new Date object based on the informed pattern . const d = new Date (); d . fromFormattedString ( '6/9/19 11:50 pm GMT +05:30' , 'M/d/yy h:m a z' ); // => Sat Jun 09 2018 18:20:00 GMT+0000 (Greenwich Mean Time) // => Sat Jun 09 2018 19:20:00 GMT+0100 (British Summer Time) // => Sat Jun 09 2018 15:20:00 GMT-0300 (Atlantic Daylight Time) // => Sun Jun 10 2018 02:20:00 GMT+0800 (China Standard Time) A pattern take only its reserved characters into consideration. Any other character is considered a separator. Two consecutive separators aren\u2019t allowed. If the pattern has no separator, the date string doesn\u2019t either. In this case, only full elements (with leading zeros) are allowed. If a separator in the pattern doesn\u2019t match a separator in the date string, with the same sequence, or if the content between two separators isn\u2019t numeric, an error will be raised. If a pattern element isn\u2019t recognized, an error will be raised.","title":"fromFormattedString"},{"location":"date/#toformattednumber","text":"toFormattedNumber(pattern?: string, timeZone?: string): string toFormattedNumber(pattern?: string, localTime?: boolean): string The same as the above function, accepting no separators as pattern . const d = new Date ( 2019 , 5 , 11 ); d . fromFormattedNumber ( 20190906 , 'yyyyMMdd' ); // => Sun Jun 09 2019 00:00:00 GMT+0000","title":"toFormattedNumber"},{"location":"date/#toformattedstring","text":"Date.prototype.toFormattedString(pattern?: string, timeZone?: string): string Date.prototype.toFormattedString(pattern?: string, localTime?: boolean): string Returns the date according to the specified pattern . If no pattern is specified, ISO 8601 ( 'yyyy-MM-ddTHH:mm:ssZ' ) is assumed; If no time zone is specified, UTC is assumed; Instead of a time zone, you can send true to the second parameter, thus assuming the environment local time. const d = new Date ( Date . UTC ( 2018 , 5 , 9 , 16 , 0 , 30 , 95 )); d . toFormattedString ()); // 1980-06-09T16:00:30+0000 d . toFormattedString ( 'yyyy/MM/dd HH:mm:ssZ' , 'GMT +01:00' ); // 1980/06/09 17:00:30+0100 d . toFormattedString ( 'yyyy/MM/dd HH:mm:ssZ' , '-0100' ); // 1980/06/09 15:00:30-0100 d . toFormattedString ( 'yyyy/MM/dd HH:mm:ss (z)' , true ); // 1980/06/09 13:00:30 (GMT -03:00)","title":"toFormattedString"},{"location":"date/#tolocalisostring","text":"Date.prototype.toLocalISOString(): string Returns local time in ISO 8601 format const d = new Date (); d . toLocalISOString (); // Just like toISOString(), but in the local format","title":"toLocalISOString"},{"location":"number/","text":"Number pow10 Number.prototype.pow10(exponent: number): number Returns the number raised n times to the power of 10 const n = 5 ; n . pow10 ( - 3 ); // => 0.005 n . pow10 ( 3 ); // => 5000 Single argument Math functions Number.prototype[function](): number For sheer convenience, every function from the Math built-in object which takes a single argument is accessible from any number instance. Those are abs , acos , acosh , asin , asinh , atan , atanh , cbrt , ceil , clz32 , cos , cosh , exp , expm1 , floor , fround , log10 , log1p , log2 , round , sign , sin , sinh , sqrt , tan , tanh , and trunc . Access MDN for further documentation on each one. let n = - 7.6 ; console . log ( ` ${ n . floor () } , ${ n . ceil () } , ${ n . round () } , ${ n . trunc () } ` ); // => -8, -7, -8, -7 n = n . abs (); console . log ( ` ${ n . floor () } , ${ n . ceil () } , ${ n . round () } , ${ n . trunc () } ` ); // => 7, 8, 7, 7 Note As of ES2016, Math.pow(x, y) can ben stated as x ** y toDate Number<T>.prototype.toDate(pattern: string): Date Alias of Date.prototype.fromFormattedNumber","title":"number"},{"location":"number/#number","text":"","title":"Number"},{"location":"number/#pow10","text":"Number.prototype.pow10(exponent: number): number Returns the number raised n times to the power of 10 const n = 5 ; n . pow10 ( - 3 ); // => 0.005 n . pow10 ( 3 ); // => 5000","title":"pow10"},{"location":"number/#single-argument-math-functions","text":"Number.prototype[function](): number For sheer convenience, every function from the Math built-in object which takes a single argument is accessible from any number instance. Those are abs , acos , acosh , asin , asinh , atan , atanh , cbrt , ceil , clz32 , cos , cosh , exp , expm1 , floor , fround , log10 , log1p , log2 , round , sign , sin , sinh , sqrt , tan , tanh , and trunc . Access MDN for further documentation on each one. let n = - 7.6 ; console . log ( ` ${ n . floor () } , ${ n . ceil () } , ${ n . round () } , ${ n . trunc () } ` ); // => -8, -7, -8, -7 n = n . abs (); console . log ( ` ${ n . floor () } , ${ n . ceil () } , ${ n . round () } , ${ n . trunc () } ` ); // => 7, 8, 7, 7 Note As of ES2016, Math.pow(x, y) can ben stated as x ** y","title":"Single argument Math functions"},{"location":"number/#todate","text":"Number<T>.prototype.toDate(pattern: string): Date Alias of Date.prototype.fromFormattedNumber","title":"toDate"},{"location":"pattern/","text":"Patterns Pattern Result yyyy 4-digit year yy 2-digit year MM 2-digit month M month without leading zero dd 2-digit day d Day without leading zero HH 2-digit 24-hour hours H 24-hour hours without leading zero hh 2-digit 12-hour hours h 12-hour hours without leading zero mm 2-digit minutes m Minutes without leading zeros ss 2-digit seconds s Seconds without leading zeros SSS 3-digit milliseconds S Milliseconds without leading zeros Z RFC 822 time zone: \u00b1hhmm or simply \u00b1hh z General time zone: GMT \u00b1hh:mm A AM/PM upper cased a am/pm lower cased","title":"patterns"},{"location":"pattern/#patterns","text":"Pattern Result yyyy 4-digit year yy 2-digit year MM 2-digit month M month without leading zero dd 2-digit day d Day without leading zero HH 2-digit 24-hour hours H 24-hour hours without leading zero hh 2-digit 12-hour hours h 12-hour hours without leading zero mm 2-digit minutes m Minutes without leading zeros ss 2-digit seconds s Seconds without leading zeros SSS 3-digit milliseconds S Milliseconds without leading zeros Z RFC 822 time zone: \u00b1hhmm or simply \u00b1hh z General time zone: GMT \u00b1hh:mm A AM/PM upper cased a am/pm lower cased","title":"Patterns"},{"location":"string/","text":"String Caution Using regular expression is dangerous for it exposes your system to ReDoS attacks. Basically a malicious user could craft a special input to hang your server idle at 100%. Some reports from the past are CVE-2017-16021 , CVE-2018-13863 , and CVE-2018-8926 . Even if you\u2019re sure all submitted strings are trusted, quality software tools will raise security concerns pointing to any RegEx code. So prefer the safeReplace function from this package instead of the bundled String.prototype.replace. There\u2019s also other permutations to replace first or all, case sensitive or insensitive. capitalize String.prototype.capitalize(): string Returns the string in lower case, except for the first letter of each word which will be upper cased. 'life before death' . capitalize (); // => 'Life Before Death' centerPad String.prototype.centerPad(size: number, pad?: string): string Returns the string with the specified size, using the specified character to both sides to complete the length, centering the word. If no character is specified, blank is assumed. If the number is even, the string will be one position to the left '12' . centerPad ( 5 , 'a' ); // => 'a12aa' '12' . centerPad ( 3 ); // => '12 ' contains String.prototype.contains(str: string): string Returns true if the substring is present, case sensitive 'strength before weakness' . contains ( 'after' ); // false 'journey before destination' . contains ( 'destination' ); // true containsIgnoreCase String.prototype.containsIgnoreCase(str: string): string Returns true if the substring is present, regardless the case 'I will protect those' . containsIgnoreCase ( 'PROTECT' ); // true 'who cannot protect themselves' . containsIgnoreCase ( 'Those' ;) // false firstChar String.prototype.firstChar(): string Equivalent to \u2018\u2019.charAt(0) 'StormLight' . firstChar (); // => 'S' isNumeric String.prototype.isNumeric(): boolean Returns true if the string represents a number '0' . isNumeric (); // => true '-1' . isNumeric (); // => true '1' . isNumeric (); // => true '-1.7' . isNumeric (); // => true '8e5' . isNumeric (); // => true '*2a' . isNumeric (); // => false '\\t\\t' . isNumeric (); // => false lastChar String.prototype.lastChar(): string Equivalent to s.charAt(s.length -1); 'StormLight' . lastChar (); // => 't' leftPad String.prototype.leftPad(size: number, pad?: string): string Important As of ES2017 , use String\u200b.prototype\u200b.pad\u200bStart() instead. Returns the string with the specified size, using the specified character to the lef to complete the length. If no character is specified, blank is assumed. '123' . leftPad ( 5 , '_' ); // => '__123' '123' . leftPad ( 5 ); // => ' 123' replaceAll String.prototype.replaceAll(target: string, replacement: string): string Returns a new string the first case sensitive occurrences of target replaced by the replacement string. 'I will protect even those I hate' . replaceAll ( ' ' , '_' ); // => 'I_will_protect_even_those_I_hate' replaceAllIgnoreCase String.prototype.replaceAllIgnoreCase(target: string, replacement: string): string Returns a new string with all case sensitive occurrences of target replaced by the replacement string. 'I will take responsibility' . replaceAllIgnoreCase ( 'i' , '!' ); // => '! w!ll take respons!b!l!ty' replaceIgnoreCase String.prototype.replaceIgnoreCase(target: string, replacement: string): string Returns a new string with the first occurrence of target replaced by the replacement string, regardless the case. 'I will listen to those who have been ignored.' . replaceIgnoreCase ( 'WHO HAVE' , 'WHO\\'VE' ); // => 'I will listen to those WHO'VE been ignored.' rightPad String.prototype.rightPad(size: number, pad?: string): string Important As of ES2017 , use String\u200b.prototype\u200b.pad\u200bEnd() instead. Returns the string with the specified size, using the specified character to the right to complete the length. If no character is specified, blank is assumed. '123' . leftPad ( 5 , '_' ); // => '123__' '123' . leftPad ( 5 ,); // => '123 ' safeReplace String.prototype.safeReplace(target: string, replacement: string): string Returns a new string with the first case sensitive occurrence of target replaced by the replacement string. Choose this function over the bundled String\u200b.prototype\u200b.replace() if you don\u2019t need to support regular expressions. 'I will listen to those who have been ignored.' . replaceIgnoreCase ( 'WHO HAVE' , 'WHO\\'VE' ); // => 'I will listen to those WHO'VE been ignored.' strip String.prototype.strip(targets: string | Array<string>): string; Strips the string of all characters or words passed to the function. '1980-06-09T19:00:00.000Z' . strip ( '-' , ':' , '.' , 't' , 'z' ); // => '19800609T190000000Z' stripIgnoreCase String.prototype.strip(targets: string | Array<string>): string; Strips the string of all characters or words passed to the function, regardless the case '1980-06-09T19:00:00.000Z' . strip ( '-' , ':' , '.' , 't' , 'z' ); // => '19800609190000000' substringFrom String.prototype.substringFrom(str: string): string Returns the string from the first occurrence of the specified substring to the end. It\u2019s case sensitive. 'I will remember those who have been forgotten.' . substringFrom ( 'r' ); // => 'remember those who have been forgotten.' substringFromLast String.prototype.substringFromLast(str: string): string Returns the string from the last occurrence of the specified substring to the end. It\u2019s case sensitive. 'I will remember those who have been forgotten.' . substringFrom ( 'r' ); // => 'gotten.' substringUpTo String.prototype.substringUpTo(str: string): string Returns the string up until the first occurrence of the the specified substring, exclusive and case sensitive. 'I will unite instead of divide.' . substringUpTo ( 'e' ); // => 'I will unit' substringUpToLast String.prototype.substringUpToLast(str: string): string Returns the string up until the last occurrence of the the specified substring, exclusive and case sensitive. 'I will unite instead of divide.' . substringUpToLast ( 'e' ); // => 'I will unite instead of divid' toASCII String.prototype.toASCII(): string Strips the string of accented characters, downgrading the encode to simple ASCII const sample = 'Fa\u00e7ade Caf\u00e9 R\u00e9sum\u00e9' sample . toASCII (); // => Facade Cafe Resume toDate String.prototype.toDate(pattern: string): Date Alias of Date.prototype.fromFormattedString","title":"string"},{"location":"string/#string","text":"Caution Using regular expression is dangerous for it exposes your system to ReDoS attacks. Basically a malicious user could craft a special input to hang your server idle at 100%. Some reports from the past are CVE-2017-16021 , CVE-2018-13863 , and CVE-2018-8926 . Even if you\u2019re sure all submitted strings are trusted, quality software tools will raise security concerns pointing to any RegEx code. So prefer the safeReplace function from this package instead of the bundled String.prototype.replace. There\u2019s also other permutations to replace first or all, case sensitive or insensitive.","title":"String"},{"location":"string/#capitalize","text":"String.prototype.capitalize(): string Returns the string in lower case, except for the first letter of each word which will be upper cased. 'life before death' . capitalize (); // => 'Life Before Death'","title":"capitalize"},{"location":"string/#centerpad","text":"String.prototype.centerPad(size: number, pad?: string): string Returns the string with the specified size, using the specified character to both sides to complete the length, centering the word. If no character is specified, blank is assumed. If the number is even, the string will be one position to the left '12' . centerPad ( 5 , 'a' ); // => 'a12aa' '12' . centerPad ( 3 ); // => '12 '","title":"centerPad"},{"location":"string/#contains","text":"String.prototype.contains(str: string): string Returns true if the substring is present, case sensitive 'strength before weakness' . contains ( 'after' ); // false 'journey before destination' . contains ( 'destination' ); // true","title":"contains"},{"location":"string/#containsignorecase","text":"String.prototype.containsIgnoreCase(str: string): string Returns true if the substring is present, regardless the case 'I will protect those' . containsIgnoreCase ( 'PROTECT' ); // true 'who cannot protect themselves' . containsIgnoreCase ( 'Those' ;) // false","title":"containsIgnoreCase"},{"location":"string/#firstchar","text":"String.prototype.firstChar(): string Equivalent to \u2018\u2019.charAt(0) 'StormLight' . firstChar (); // => 'S'","title":"firstChar"},{"location":"string/#isnumeric","text":"String.prototype.isNumeric(): boolean Returns true if the string represents a number '0' . isNumeric (); // => true '-1' . isNumeric (); // => true '1' . isNumeric (); // => true '-1.7' . isNumeric (); // => true '8e5' . isNumeric (); // => true '*2a' . isNumeric (); // => false '\\t\\t' . isNumeric (); // => false","title":"isNumeric"},{"location":"string/#lastchar","text":"String.prototype.lastChar(): string Equivalent to s.charAt(s.length -1); 'StormLight' . lastChar (); // => 't'","title":"lastChar"},{"location":"string/#leftpad","text":"String.prototype.leftPad(size: number, pad?: string): string Important As of ES2017 , use String\u200b.prototype\u200b.pad\u200bStart() instead. Returns the string with the specified size, using the specified character to the lef to complete the length. If no character is specified, blank is assumed. '123' . leftPad ( 5 , '_' ); // => '__123' '123' . leftPad ( 5 ); // => ' 123'","title":"leftPad"},{"location":"string/#replaceall","text":"String.prototype.replaceAll(target: string, replacement: string): string Returns a new string the first case sensitive occurrences of target replaced by the replacement string. 'I will protect even those I hate' . replaceAll ( ' ' , '_' ); // => 'I_will_protect_even_those_I_hate'","title":"replaceAll"},{"location":"string/#replaceallignorecase","text":"String.prototype.replaceAllIgnoreCase(target: string, replacement: string): string Returns a new string with all case sensitive occurrences of target replaced by the replacement string. 'I will take responsibility' . replaceAllIgnoreCase ( 'i' , '!' ); // => '! w!ll take respons!b!l!ty'","title":"replaceAllIgnoreCase"},{"location":"string/#replaceignorecase","text":"String.prototype.replaceIgnoreCase(target: string, replacement: string): string Returns a new string with the first occurrence of target replaced by the replacement string, regardless the case. 'I will listen to those who have been ignored.' . replaceIgnoreCase ( 'WHO HAVE' , 'WHO\\'VE' ); // => 'I will listen to those WHO'VE been ignored.'","title":"replaceIgnoreCase"},{"location":"string/#rightpad","text":"String.prototype.rightPad(size: number, pad?: string): string Important As of ES2017 , use String\u200b.prototype\u200b.pad\u200bEnd() instead. Returns the string with the specified size, using the specified character to the right to complete the length. If no character is specified, blank is assumed. '123' . leftPad ( 5 , '_' ); // => '123__' '123' . leftPad ( 5 ,); // => '123 '","title":"rightPad"},{"location":"string/#safereplace","text":"String.prototype.safeReplace(target: string, replacement: string): string Returns a new string with the first case sensitive occurrence of target replaced by the replacement string. Choose this function over the bundled String\u200b.prototype\u200b.replace() if you don\u2019t need to support regular expressions. 'I will listen to those who have been ignored.' . replaceIgnoreCase ( 'WHO HAVE' , 'WHO\\'VE' ); // => 'I will listen to those WHO'VE been ignored.'","title":"safeReplace"},{"location":"string/#strip","text":"String.prototype.strip(targets: string | Array<string>): string; Strips the string of all characters or words passed to the function. '1980-06-09T19:00:00.000Z' . strip ( '-' , ':' , '.' , 't' , 'z' ); // => '19800609T190000000Z'","title":"strip"},{"location":"string/#stripignorecase","text":"String.prototype.strip(targets: string | Array<string>): string; Strips the string of all characters or words passed to the function, regardless the case '1980-06-09T19:00:00.000Z' . strip ( '-' , ':' , '.' , 't' , 'z' ); // => '19800609190000000'","title":"stripIgnoreCase"},{"location":"string/#substringfrom","text":"String.prototype.substringFrom(str: string): string Returns the string from the first occurrence of the specified substring to the end. It\u2019s case sensitive. 'I will remember those who have been forgotten.' . substringFrom ( 'r' ); // => 'remember those who have been forgotten.'","title":"substringFrom"},{"location":"string/#substringfromlast","text":"String.prototype.substringFromLast(str: string): string Returns the string from the last occurrence of the specified substring to the end. It\u2019s case sensitive. 'I will remember those who have been forgotten.' . substringFrom ( 'r' ); // => 'gotten.'","title":"substringFromLast"},{"location":"string/#substringupto","text":"String.prototype.substringUpTo(str: string): string Returns the string up until the first occurrence of the the specified substring, exclusive and case sensitive. 'I will unite instead of divide.' . substringUpTo ( 'e' ); // => 'I will unit'","title":"substringUpTo"},{"location":"string/#substringuptolast","text":"String.prototype.substringUpToLast(str: string): string Returns the string up until the last occurrence of the the specified substring, exclusive and case sensitive. 'I will unite instead of divide.' . substringUpToLast ( 'e' ); // => 'I will unite instead of divid'","title":"substringUpToLast"},{"location":"string/#toascii","text":"String.prototype.toASCII(): string Strips the string of accented characters, downgrading the encode to simple ASCII const sample = 'Fa\u00e7ade Caf\u00e9 R\u00e9sum\u00e9' sample . toASCII (); // => Facade Cafe Resume","title":"toASCII"},{"location":"string/#todate","text":"String.prototype.toDate(pattern: string): Date Alias of Date.prototype.fromFormattedString","title":"toDate"}]}